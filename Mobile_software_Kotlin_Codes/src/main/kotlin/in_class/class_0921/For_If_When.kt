package in_class.class_0921import in_class.class_0921.DayOfWeak.*// enumeration : 나열 (비슷한 성질 끼리). Top-level Classenum class DayOfWeak {                     // 비슷한 성질 끼리 클래스 단위로 그룹핑    SUN, MON, TUE, WED, THU, FRI, SAT}class For_If_When {    fun If() {        // class 는 곧 Type 이다. (Primitive Type 이 아닌 사용자 정의 Type)        val s: DayOfWeak = SUN        if (s == SUN) println("일요일") // Mutually Exclusive        else if (s == MON) println("월요일")        else if (s == TUE) println("화요일")        else if (s == WED) println("수요일")        else if (s == THU) println("목요일")        else if (s == FRI) println("금요일")        else println("토요일")//        else if (s == "SAT") println("토요일")    }    fun When() {        // class 는 곧 Type 이다. (Primitive Type 이 아닌 사용자 정의 Type)        val s: DayOfWeak = SUN        when (s) {            SUN -> println("일요일")            MON -> println("월요일")            TUE -> println("화요일")            WED -> println("수요일")            THU -> println("목요일")            FRI -> println("금요일")            else -> println("토요일")//            SAT -> println("토요일")        }        // when expression        val t = when (s) {            MON, TUE, WED, THU, FRI -> "Week Day"            SUN, SAT -> "Week End"        }        println("When Expression = $t")        if (s == SUN) println("일요일") // Mutually Exclusive        else if (s == MON) println("월요일")        else if (s == TUE) println("화요일")        else if (s == WED) println("수요일")        else if (s == THU) println("목요일")        else if (s == FRI) println("금요일")        else println("토요일")//        else if (s == "SAT") println("토요일")    }    fun For() {        var sum = 0        for (i in 10 downTo  1 step 2) {            print("$i ")        }    }    // call By Value (값 변경 못함)    fun for_return(start: Int, end: Int): Int {        var sum = 0        var newStart = start        var newEnd = end        if(start == end)            return start        if (start > end) {            newStart = end            newEnd = start        }        for (i in newStart..newEnd) {            sum += 1        }        return sum    }}